`timescale 1ns / 1ps

module Seg_Driver(
    input clk,
    input rst_n,
    input [31:0] display_val,  // 显示数值
    output reg [7:0] seg_out,  // 段选信号
    output reg [7:0] seg_an    // 位选信号
);

// 数码管显示编码查找表 (共阳极数码管，0点亮)
// 格式: {dp, g, f, e, d, c, b, a}
localparam [7:0] 
    SEG_0 = 8'b11000000,  // 0
    SEG_1 = 8'b11111001,  // 1
    SEG_2 = 8'b10100100,  // 2
    SEG_3 = 8'b10110000,  // 3
    SEG_4 = 8'b10011001,  // 4
    SEG_5 = 8'b10010010,  // 5
    SEG_6 = 8'b10000010,  // 6
    SEG_7 = 8'b11111000,  // 7
    SEG_8 = 8'b10000000,  // 8
    SEG_9 = 8'b10010000,  // 9
    SEG_A = 8'b10001000,  // A
    SEG_B = 8'b10000011,  // b
    SEG_C = 8'b11000110,  // C
    SEG_D = 8'b10100001,  // d
    SEG_E = 8'b10000110,  // E
    SEG_F = 8'b10001110,  // F
    SEG_R = 8'b10101111,  // r (特殊字符)
    SEG_MINUS = 8'b10111111, // -
    SEG_BLANK = 8'b11111111; // 空白

// 字母编码定义
localparam 
    CHAR_A = 4'hA,
    CHAR_B = 4'hB,
    CHAR_C = 4'hC,
    CHAR_D = 4'hD,
    CHAR_E = 4'hE,
    CHAR_F = 4'hF,
    CHAR_R = 4'h7,  // 特殊定义
    CHAR_MINUS = 4'h8, // 减号
    CHAR_BLANK = 4'h9; // 空白

// 动态扫描计数器
reg [19:0] scan_counter;
wire scan_clk = (scan_counter == 20'd100000); // 约1kHz扫描频率

// 当前扫描的数码管位
reg [2:0] scan_pos;

// 当前显示的数字/字符
reg [3:0] current_digit;

// 显示缓冲区
reg [3:0] display_buffer [7:0];

// 扫描计数器
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        scan_counter <= 20'b0;
    else
        scan_counter <= scan_counter + 1'b1;
end

// 扫描位置更新
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        scan_pos <= 3'b0;
    else if (scan_clk)
        scan_pos <= scan_pos + 1'b1;
end

// 解析display_val到显示缓冲区
always @(posedge clk or negedge rst_n) begin
    if (!rst_n) begin
        // 复位时显示空白
        display_buffer[0] <= CHAR_BLANK;
        display_buffer[1] <= CHAR_BLANK;
        display_buffer[2] <= CHAR_BLANK;
        display_buffer[3] <= CHAR_BLANK;
        display_buffer[4] <= CHAR_BLANK;
        display_buffer[5] <= CHAR_BLANK;
        display_buffer[6] <= CHAR_BLANK;
        display_buffer[7] <= CHAR_BLANK;
    end else begin
        // 根据文档要求解析显示内容
        // display_val[31:0] 包含要显示的信息
        // 这里根据具体应用场景解析，例如：
        // - 显示运算模式字符 (如 "C-A-L-C")
        // - 显示错误倒计时 (如 "Err 10")
        
        // 示例：显示运算模式
        case (display_val[3:0]) // 假设低4位表示运算模式
            4'b0000: begin // 空闲状态
                display_buffer[7] <= CHAR_BLANK;
                display_buffer[6] <= CHAR_BLANK;
                display_buffer[5] <= CHAR_BLANK;
                display_buffer[4] <= CHAR_BLANK;
                display_buffer[3] <= CHAR_C;  // C
                display_buffer[2] <= CHAR_A;  // A
                display_buffer[1] <= CHAR_L;  // L
                display_buffer[0] <= CHAR_C;  // C
            end
            4'b0001: begin // 加法模式
                display_buffer[7] <= CHAR_BLANK;
                display_buffer[6] <= CHAR_BLANK;
                display_buffer[5] <= CHAR_BLANK;
                display_buffer[4] <= CHAR_BLANK;
                display_buffer[3] <= CHAR_A;  // A
                display_buffer[2] <= CHAR_D;  // d
                display_buffer[1] <= CHAR_D;  // d
                display_buffer[0] <= CHAR_BLANK;
            end
            4'b0010: begin // 乘法模式
                display_buffer[7] <= CHAR_BLANK;
                display_buffer[6] <= CHAR_BLANK;
                display_buffer[5] <= CHAR_BLANK;
                display_buffer[4] <= CHAR_BLANK;
                display_buffer[3] <= CHAR_M;  // M
                display_buffer[2] <= CHAR_U;  // u
                display_buffer[1] <= CHAR_L;  // l
                display_buffer[0] <= CHAR_BLANK;
            end
            4'b0011: begin // 错误显示 "Err XX"
                display_buffer[7] <= CHAR_E;  // E
                display_buffer[6] <= CHAR_R;  // r
                display_buffer[5] <= CHAR_R;  // r
                display_buffer[4] <= CHAR_BLANK;
                display_buffer[3] <= display_val[11:8];  // 十位数
                display_buffer[2] <= display_val[7:4];   // 个位数
                display_buffer[1] <= CHAR_BLANK;
                display_buffer[0] <= CHAR_BLANK;
            end
            default: begin // 默认显示
                display_buffer[7] <= CHAR_BLANK;
                display_buffer[6] <= CHAR_BLANK;
                display_buffer[5] <= CHAR_BLANK;
                display_buffer[4] <= CHAR_BLANK;
                display_buffer[3] <= CHAR_BLANK;
                display_buffer[2] <= CHAR_BLANK;
                display_buffer[1] <= CHAR_BLANK;
                display_buffer[0] <= CHAR_BLANK;
            end
        endcase
    end
end

// 选择当前要显示的数字
always @(*) begin
    case (scan_pos)
        3'b000: current_digit = display_buffer[0];
        3'b001: current_digit = display_buffer[1];
        3'b010: current_digit = display_buffer[2];
        3'b011: current_digit = display_buffer[3];
        3'b100: current_digit = display_buffer[4];
        3'b101: current_digit = display_buffer[5];
        3'b110: current_digit = display_buffer[6];
        3'b111: current_digit = display_buffer[7];
        default: current_digit = CHAR_BLANK;
    endcase
end

// 段选信号输出
always @(*) begin
    case (current_digit)
        4'h0: seg_out = SEG_0;
        4'h1: seg_out = SEG_1;
        4'h2: seg_out = SEG_2;
        4'h3: seg_out = SEG_3;
        4'h4: seg_out = SEG_4;
        4'h5: seg_out = SEG_5;
        4'h6: seg_out = SEG_6;
        4'h7: seg_out = SEG_7;
        4'h8: seg_out = SEG_8;
        4'h9: seg_out = SEG_9;
        CHAR_A: seg_out = SEG_A;
        CHAR_B: seg_out = SEG_B;
        CHAR_C: seg_out = SEG_C;
        CHAR_D: seg_out = SEG_D;
        CHAR_E: seg_out = SEG_E;
        CHAR_F: seg_out = SEG_F;
        CHAR_R: seg_out = SEG_R;
        CHAR_MINUS: seg_out = SEG_MINUS;
        CHAR_BLANK: seg_out = SEG_BLANK;
        default: seg_out = SEG_BLANK;
    endcase
end

// 位选信号输出 (共阳极，低电平有效)
always @(*) begin
    case (scan_pos)
        3'b000: seg_an = 8'b11111110;
        3'b001: seg_an = 8'b11111101;
        3'b010: seg_an = 8'b11111011;
        3'b011: seg_an = 8'b11110111;
        3'b100: seg_an = 8'b11101111;
        3'b101: seg_an = 8'b11011111;
        3'b110: seg_an = 8'b10111111;
        3'b111: seg_an = 8'b01111111;
        default: seg_an = 8'b11111111;
    endcase
end

// 字母定义补充
localparam 
    CHAR_M = 4'hB,  // 复用B的定义，实际使用时需要调整
    CHAR_U = 4'hC,  // 复用C的定义
    CHAR_L = 4'hD;  // 复用D的定义

endmodule