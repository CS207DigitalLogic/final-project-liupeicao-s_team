# FPGA 矩阵计算器 - 满分演示操作指南

本文档旨在为课堂检查提供一套完整的、能够展示所有加分项的操作流程（Script）。请严格按照以下步骤进行演示，以确保覆盖所有评分点（特别是 Bonus 和 动态配置功能）。

## 1. 硬件与环境准备

*   **FPGA 开发板**: 确认电源连接正常。
*   **PC 连接**: 使用 USB-UART 线连接开发板与电脑。
*   **串口助手设置**:
    *   **波特率**: `115200` (注意：代码中 top.v 实例化时设置为 115200，请务必确认)
    *   **数据位**: 8
    *   **停止位**: 1
    *   **校验位**: None
    *   **发送设置**: 勾选“发送新行”或手动发送 Hex/ASCII (本项目 `cmd_parser` 解析十进制数字字符)。建议使用支持直接发送文本的助手。

## 2. 核心功能速查表

| 模式 (SW[7:5]) | 功能描述 | 关键操作 | 备注 |
| :--- | :--- | :--- | :--- |
| **000** | **Input (输入)** | 串口发送 `M` -> `N` -> `数据...` | 输入完 M 和 N 后 LED 会指示 |
| **001** | **Gen (随机)** | 按下 `Btn_C` | 随机填充矩阵 A |
| **010** | **Display (展示)** | SW[1:0]选矩阵 -> 按 `Btn_C` | 串口打印指定矩阵 |
| **011** | **Calc (计算)** | SW[4:2]选运算 -> 按 `Btn_C` -> SW选矩阵 -> 按 `Btn_C` | 支持 + - * 数乘 转置 |
| **100** | **Bonus (卷积)** | 按下 `Btn_C` | 运行卷积，显示周期数 |
| **101** | **Config (配置)** | 串口发送 `5-15` 的数字 | **加分项**：动态修改报错倒计时 |

## 3. 满分演示剧本 (Step-by-Step)

请按照以下顺序向老师或助教演示。

### 第一步：展示“动态配置”功能 (体现系统灵活性)
> **话术**: “首先，我演示一下系统的可配置性。默认错误倒计时是 10秒，我现在将其修改为 5秒。”

1.  拨动开关 `SW[7:5]` 至 `101` (Config Mode)。
2.  在串口助手发送数字 `5`。
3.  (可选) 此时系统内部已更新配置，稍后在演示错误时可以验证。
4.  拨回 `SW[7:5]` 至 `000` (回到 IDLE 准备输入)。

### 第二步：矩阵输入与展示 (验证基础功能)
> **话术**: “现在我输入两个矩阵，矩阵 A 为 2x3，矩阵 B 为 3x2，用于演示乘法。”

1.  **输入矩阵 A (Slot 0)**:
    *   拨动 `SW[7:5]=000` (Input Mode)。
    *   拨动 `SW[1:0]=00` (Select Slot A)。
    *   按下 `Btn_C` 确认进入输入状态。
    *   串口发送: `2` (行), `3` (列)。(等待 LED 确认或直接继续)
    *   串口发送: `1 2 3 4 5 6` (6个元素，空格或回车分隔)。
    *   **现象**: 输入完成后，系统自动回到 IDLE。

2.  **输入矩阵 B (Slot 1)**:
    *   保持 `SW[7:5]=000`。
    *   拨动 `SW[1:0]=01` (Select Slot B)。
    *   按下 `Btn_C`。
    *   串口发送: `3` (行), `2` (列)。
    *   串口发送: `1 4 2 5 3 6`。

3.  **展示矩阵**:
    *   拨动 `SW[7:5]=010` (Display Mode)。
    *   拨动 `SW[1:0]=00` (Slot A)，按 `Btn_C` -> 串口应打印矩阵 A。
    *   拨动 `SW[1:0]=01` (Slot B)，按 `Btn_C` -> 串口应打印矩阵 B。

### 第三步：矩阵计算 (验证核心算法)
> **话术**: “接下来进行矩阵乘法运算 A * B。”

1.  拨动 `SW[7:5]=011` (Calc Mode)。
2.  拨动 `SW[4:2]=010` (乘法 Opcode, 假设 010 为乘法，具体请参考下方 Opcode 表)。
    *   *注: 000=Add, 001=Sub, 010=Mul, 011=Scalar, 100=Trans*
3.  按下 `Btn_C` (进入 Select Matrix 状态)。
4.  (乘法默认使用 Slot 0 和 Slot 1，此处直接确认即可，或者根据设计选择操作数)。
5.  按下 `Btn_C` (Confirm)。
6.  **现象**:
    *   数码管显示 `CALC` -> `dOnE`。
    *   串口自动打印结果矩阵 C (2x2 矩阵)。

### 第四步：错误处理与“光速重试” (展示高级交互)
> **话术**: “现在演示错误处理。我尝试将 A (2x3) 与 A (2x3) 相加，这违反了维度规则。同时演示在倒计时结束前快速修正错误的机制。”

1.  保持 `SW[7:5]=011` (Calc Mode)。
2.  拨动 `SW[4:2]=000` (加法 Opcode)。
3.  按下 `Btn_C`。
4.  **故意错误**: 此时系统尝试 A+B (2x3 + 3x2)，维度不匹配。
5.  按下 `Btn_C` (Confirm)。
6.  **现象**:
    *   数码管显示 `Err` 和倒计时 (从 5 开始，因为第一步设置了 5秒)。
    *   LED 闪烁。
7.  **操作 (加分点)**: 不用等倒计时结束！
    *   快速拨动 `SW[4:2]=100` (转置运算，单操作数，总是合法)。
    *   或者解释说“啊，我选错运算了”，然后再次按下 `Btn_C`。
    *   **现象**: 系统立即跳出错误状态，重新进行检查/计算 (如果逻辑允许直接跳回 Check) 或者回到选择状态。
    *   *(注: 如果逻辑是跳回 Check，则需要确保新的设置是合法的。如果逻辑是跳回 Select，则可以重新选择)*。
    *   *根据代码逻辑，在 Error 状态按 Btn_C 会触发 `calc_mat_conf` 跳转到 Check。所以如果在 Error 期间修改了 SW 设置使得操作合法（例如切到转置），按 Btn_C 应该能直接成功！*

### 第五步：Bonus 卷积与性能分析 (压轴戏)
> **话术**: “最后演示 Bonus 功能。系统内置了 10x12 的图像，我们将使用一个 3x3 的卷积核进行运算，并统计消耗的时钟周期数。”

1.  **准备**: 确保之前输入过一个 3x3 的矩阵作为卷积核 (Kernel)。
    *   如果没有，可以快速用 Input 模式在 Slot A 输入一个 3x3 矩阵 (例如全1矩阵)。
2.  **进入 Bonus 模式**:
    *   拨动 `SW[7:5]=100`。
3.  **执行**:
    *   按下 `Btn_C`。
4.  **现象**:
    *   数码管显示 `run` (或类似状态)。
    *   计算完成后，串口打印卷积结果 (8x10 矩阵流)。
    *   **关键**: 数码管显示 `Cy  XXXX` (例如 `Cy 1234`)，表示消耗的时钟周期。
    *   向老师解释：“这是硬件加速的实时周期计数，精确评估了运算性能。”

## 4. 附录：Opcode 对照表

| SW[4:2] | 运算 | 符号显示 |
| :--- | :--- | :--- |
| **000** | Addition (A+B) | `A` |
| **001** | Subtraction (A-B) | `b` (Sub) |
| **010** | Multiplication (A*B) | `C` (Cross/Mul) |
| **011** | Scalar Mul (k*A) | `S` (Scalar) |
| **100** | Transpose (A^T) | `t` (Trans) |

## 5. 常见问题 (Troubleshooting)

*   **数码管显示 `Err` 不消失**: 检查是否在倒计时？等待结束或按下 Btn_C 重试。
*   **串口无输出**: 检查波特率是否为 115200。
*   **输入矩阵没反应**: 检查是否先输入了 M 和 N。
